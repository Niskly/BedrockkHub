<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Minecraft-style 3D Armor Viewer</title>
<style>
  html,body { height:100%; margin:0; background:#111; color:#fff; font-family:Inter,system-ui,Arial; }
  #ui {
    position:absolute; left:12px; top:12px; z-index:10;
    background:rgba(0,0,0,0.4); padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.06);
  }
  #upload { cursor:pointer; padding:8px 12px; border-radius:8px; background:linear-gradient(135deg,#de212a,#b21a22); color:#fff; font-weight:700; }
  #info { margin-top:8px; font-size:13px; color:#c8cbe0; }
  canvas { display:block; width:100vw; height:100vh; }
  .small { font-size:12px; color:#bfc7e6; }
</style>
</head>
<body>
<div id="ui">
  <button id="upload">Upload .zip / .mcpack</button>
  <input id="file" type="file" accept=".zip,.mcpack" style="display:none" />
  <div id="info" class="small">Drag to rotate • Wheel to zoom • Upload a resource pack to apply real armor textures.</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
/* ------- Scene setup ------- */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a1a);

const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(6, 5, 10);
camera.lookAt(0, 3, 0);

const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(5, 10, 7);
scene.add(dir);

/* ------- Armor group (mannequin) ------- */
const armorGroup = new THREE.Group();
scene.add(armorGroup);

/* Default material until we load textures */
const defaultMat = new THREE.MeshLambertMaterial({ color: 0x7f7fd1, transparent:true, opacity:0.95 });

/* Helper that creates a box with per-face materials (so we can offset each face later if needed) */
function createBox(w,h,d, x,y,z, materialOrMaterials){
  const geo = new THREE.BoxGeometry(w,h,d);
  const mesh = new THREE.Mesh(geo, materialOrMaterials || defaultMat);
  mesh.position.set(x,y,z);
  return mesh;
}

/* Build accurate-ish sub-cubes for each armor piece.
   Sizes are in Minecraft "units" where 1 unit = 1 blockpixel scaled to a display size.
   We create outer shells slightly inflated to mimic armor overlay. */
const pieces = {
  // Helmet outer shell (slightly bigger than head)
  helmet: createBox(1.2, 1.2, 1.2, 0, 4.5, 0),
  // Chest: torso + two shoulder pads
  chest: createBox(1.6, 2.2, 1.1, 0, 3.05, 0),
  leftShoulder: createBox(0.6, 0.6, 1.1, -1.15, 3.85, 0),
  rightShoulder: createBox(0.6, 0.6, 1.1, 1.15, 3.85, 0),
  // Sleeves (outer)
  leftSleeve: createBox(0.55, 2.05, 0.55, -1.15, 3.0, 0),
  rightSleeve: createBox(0.55, 2.05, 0.55, 1.15, 3.0, 0),
  // Legs outer
  leftLeg: createBox(0.6, 2.05, 0.6, -0.45, 1.0, 0),
  rightLeg: createBox(0.6, 2.05, 0.6, 0.45, 1.0, 0),
  // Boots outer
  leftBoot: createBox(0.6, 0.6, 0.6, -0.45, 0.2, 0),
  rightBoot: createBox(0.6, 0.6, 0.6, 0.45, 0.2, 0),
};

Object.values(pieces).forEach(m => armorGroup.add(m));

/* A simple grid (floor) */
const grid = new THREE.GridHelper(24, 24, 0x222244, 0x0b0b0b);
grid.position.y = -0.5;
scene.add(grid);

/* Controls: drag rotate + wheel zoom */
let drag = false, last = {x:0,y:0};
renderer.domElement.addEventListener('pointerdown', (e)=>{ drag=true; last.x=e.clientX; last.y=e.clientY; });
window.addEventListener('pointerup', ()=>drag=false);
renderer.domElement.addEventListener('pointermove', (e)=>{
  if(!drag) return;
  const dx = (e.clientX - last.x);
  const dy = (e.clientY - last.y);
  armorGroup.rotation.y += dx * 0.01;
  armorGroup.rotation.x += dy * 0.01;
  last.x = e.clientX; last.y = e.clientY;
});
window.addEventListener('wheel', (e)=>{
  camera.position.z += e.deltaY * 0.01;
  camera.position.z = Math.max(3, Math.min(30, camera.position.z));
});

/* Animation loop */
function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); }
animate();

/* ------- Texture & upload handling ------- */
const loader = new THREE.TextureLoader();
loader.crossOrigin = ''; // allow blobs/urls

let activeLayer1 = null;
let activeLayer2 = null;

/* Finds typical armor texture files in zip entries (case-insensitive)
   - checks common paths used in resource packs (assets/... and textures/...) */
function findArmorFiles(zip) {
  const candidates = {};
  const files = Object.keys(zip.files);
  // normalize file names
  for (const p of files) {
    const name = p.toLowerCase();
    if (name.endsWith('netherite_layer_1.png') || name.endsWith('diamond_layer_1.png') ||
        name.endsWith('iron_layer_1.png') || name.endsWith('gold_layer_1.png') ||
        name.endsWith('chainmail_layer_1.png') || name.endsWith('leather_layer_1.png') ||
        name.endsWith('turtle_layer_1.png')) {
      candidates.layer1 = candidates.layer1 || p;
    }
    if (name.endsWith('netherite_layer_2.png') || name.endsWith('diamond_layer_2.png') ||
        name.endsWith('iron_layer_2.png') || name.endsWith('gold_layer_2.png') ||
        name.endsWith('chainmail_layer_2.png') || name.endsWith('leather_layer_2.png')) {
      candidates.layer2 = candidates.layer2 || p;
    }
    // also look for generic armor file names
    if (name.includes('/models/armor/') && name.endsWith('.png')) {
      if (!candidates.layer1) candidates.layer1 = p; // fallback
    }
    // bedrock naming patterns (textures/models/armor/xxx_1.png, xxx_2.png)
    if (name.includes('/textures/models/armor/') && name.endsWith('_1.png') && !candidates.layer1) candidates.layer1 = p;
    if (name.includes('/textures/models/armor/') && name.endsWith('_2.png') && !candidates.layer2) candidates.layer2 = p;
  }
  return candidates;
}

/* Apply textures to armor pieces (layer1: helmet/chest/boots/arms; layer2: leggings) */
function applyTextures(layer1Tex, layer2Tex) {
  // we will use the same texture mapped across box UVs. If the resource pack uses the standard layout this will look correct.
  const t1 = layer1Tex || null;
  const t2 = layer2Tex || null;

  // set filtering for pixel-perfect look
  if (t1) { t1.magFilter = THREE.NearestFilter; t1.minFilter = THREE.NearestFilter; }
  if (t2) { t2.magFilter = THREE.NearestFilter; t2.minFilter = THREE.NearestFilter; }

  // helper to create a material that uses the texture (clone so offset/repeat don't collide)
  function matFrom(texture) {
    if (!texture) return defaultMat;
    const tex = texture.clone();
    // make sure clones use same image
    tex.needsUpdate = true;
    return new THREE.MeshLambertMaterial({ map: tex, transparent:true });
  }

  // Layer1 pieces
  const mHelmet = matFrom(t1);
  const mChest = matFrom(t1);
  const mSleeve = matFrom(t1);
  const mBoot = matFrom(t1);

  // Layer2 (leggings)
  const mLegs = matFrom(t2 || t1); // if no layer2 present, fall back to layer1

  // Apply materials:
  pieces.helmet.material = mHelmet;
  pieces.chest.material = mChest;
  pieces.leftShoulder.material = mChest;
  pieces.rightShoulder.material = mChest;
  pieces.leftSleeve.material = mSleeve;
  pieces.rightSleeve.material = mSleeve;
  pieces.leftLeg.material = mLegs;
  pieces.rightLeg.material = mLegs;
  pieces.leftBoot.material = mBoot;
  pieces.rightBoot.material = mBoot;
}

/* Read uploaded pack, find armor textures and apply them */
async function handleZipFile(file) {
  try {
    const zip = await JSZip.loadAsync(file);
    const found = findArmorFiles(zip);
    // prefer specific diamond/netherite names if present? We'll try to use the first discovered layer1/layer2
    if (!found.layer1 && !found.layer2) {
      alert('No armor textures found in pack (looking for *_layer_1.png and *_layer_2.png).');
      return;
    }

    let tex1 = null, tex2 = null;
    if (found.layer1) {
      const blob = await zip.file(found.layer1).async('blob');
      const url = URL.createObjectURL(blob);
      tex1 = await new Promise(res => loader.load(url, tex=>res(tex)));
    }
    if (found.layer2) {
      const blob2 = await zip.file(found.layer2).async('blob');
      const url2 = URL.createObjectURL(blob2);
      tex2 = await new Promise(res => loader.load(url2, tex=>res(tex)));
    }

    activeLayer1 = tex1; activeLayer2 = tex2;
    applyTextures(activeLayer1, activeLayer2);
  } catch (err) {
    console.error(err);
    alert('Failed to read pack: ' + err.message);
  }
}

/* UI wiring */
const uploadBtn = document.getElementById('upload');
const fileInput = document.getElementById('file');

uploadBtn.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', e => {
  const f = e.target.files[0];
  if (f) handleZipFile(f);
});

/* Drag & drop */
document.body.addEventListener('dragover', e => { e.preventDefault(); });
document.body.addEventListener('drop', e => {
  e.preventDefault();
  if (e.dataTransfer.files && e.dataTransfer.files.length) handleZipFile(e.dataTransfer.files[0]);
});

/* Preload a vanilla diamond layer1 texture so it looks good out of the box */
loader.load('https://raw.githubusercontent.com/InventivetalentDev/minecraft-assets/1.20.1/assets/minecraft/textures/models/armor/diamond_layer_1.png', tex=>{
  activeLayer1 = tex;
  applyTextures(activeLayer1, null);
});
</script>
</body>
</html>
